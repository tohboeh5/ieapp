<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Docs: spec/architecture/decisions.md</title><link rel="stylesheet" href="/_astro/_slug_.DCtb3bYL.css"></head> <body> <header class="mx-auto flex max-w-6xl flex-wrap items-center justify-between gap-3 px-4 py-4"> <a href="/" class="text-lg font-semibold">Ugoite Docsite</a> <nav class="flex items-center gap-4 text-sm"> <a href="/docs/guide/cli" class="underline-offset-2 hover:underline">CLI Guide</a> <a href="/docs/spec/api/rest" class="underline-offset-2 hover:underline">REST API</a> <a href="/docs/spec/api/mcp" class="underline-offset-2 hover:underline">MCP API</a> </nav> <div class="flex items-center gap-3"> <label for="theme" class="text-sm text-slate-600">Theme</label> <select id="theme" class="rounded-md border px-2 py-1 text-sm" data-theme-selector> <option value="materialize">Materialize</option><option value="classic">Classic</option><option value="pop">Pop</option> </select> <label for="mode" class="text-sm text-slate-600">Mode</label> <select id="mode" class="rounded-md border px-2 py-1 text-sm" data-mode-selector> <option value="light">Light</option> <option value="dark">Dark</option> </select> </div> <script type="module">const o="ugoite-ui-theme",l="ugoite-color-mode",m=document.documentElement,e=document.querySelector("[data-theme-selector]"),t=document.querySelector("[data-mode-selector]"),a=()=>{const c=e instanceof HTMLSelectElement?e.value:localStorage.getItem(o)||"materialize",n=t instanceof HTMLSelectElement?t.value:localStorage.getItem(l)||"light";m.dataset.uiTheme=c,m.dataset.colorMode=n,localStorage.setItem(o,c),localStorage.setItem(l,n)},i=localStorage.getItem(o)||"materialize",s=localStorage.getItem(l)||"light";e instanceof HTMLSelectElement&&(e.value=i,e.addEventListener("change",()=>{a()}));t instanceof HTMLSelectElement&&(t.value=s,t.addEventListener("change",()=>{a()}));a();</script> </header> <main class="mx-auto max-w-6xl px-4 pb-16">  <article class="prose max-w-none rounded-xl border p-6" style="background: var(--doc-card); border-color: var(--doc-border);"> <p class="mb-4 text-xs" style="color: var(--doc-muted);">Source: /docs/spec/architecture/decisions.md</p> <h1>Architecture Decision Records</h1>
<p>This document captures key architectural decisions made during Ugoite development.</p>
<h2>ADR-001: Rust Core with Python Bindings</h2>
<p><strong>Status</strong>: Accepted (Milestone 2)</p>
<p><strong>Context</strong>: </p>
<ul>
<li>Core logic was initially implemented in Python using fsspec</li>
<li>Need to support native desktop apps (Tauri) and WebAssembly</li>
<li>fsspec is Python-only, not portable to other platforms</li>
</ul>
<p><strong>Decision</strong>: 
Extract core logic into a Rust crate (<code>ugoite-core</code>) with:</p>
<ul>
<li>OpenDAL for storage abstraction (Rust-native fsspec equivalent)</li>
<li>pyo3 for Python bindings</li>
<li>wasm-bindgen for WebAssembly (future)</li>
</ul>
<p><strong>Consequences</strong>:</p>
<ul>
<li>(+) Single source of truth for core logic</li>
<li>(+) Enables native desktop app without Python runtime</li>
<li>(+) Better performance for large spaces</li>
<li>(-) Additional build complexity</li>
<li>(-) Learning curve for Rust</li>
</ul>
<hr>
<h2>ADR-002: Form-based Entry Typing</h2>
<p><strong>Status</strong>: Accepted</p>
<p><strong>Context</strong>: </p>
<ul>
<li>Users need structure without rigid database structures</li>
<li>Pure Markdown lacks metadata capabilities</li>
<li>Traditional forms are cumbersome for knowledge work</li>
</ul>
<p><strong>Decision</strong>: 
Use &quot;Forms&quot; to define entry types:</p>
<ul>
<li>Form definitions stored as JSON in <code>forms/{name}.json</code></li>
<li>Entries reference a form via frontmatter: <code>form: Meeting</code></li>
<li>H2 headers (<code>## Field</code>) become typed properties</li>
<li>Live indexer extracts and validates properties</li>
</ul>
<p><strong>Consequences</strong>:</p>
<ul>
<li>(+) Flexible: users can ignore forms entirely</li>
<li>(+) Structured: when needed, data is queryable</li>
<li>(+) Portable: standard Markdown with metadata</li>
<li>(-) Complexity: indexer must parse Markdown</li>
</ul>
<hr>
<h2>ADR-003: MCP Resource-First Integration</h2>
<p><strong>Status</strong>: Superseded (Milestone 2)</p>
<p><strong>Context</strong>:</p>
<ul>
<li>The initial plan used a sandboxed code execution tool to reduce tool surface</li>
<li>Requirements shifted to remove the Wasm sandbox in Milestone 2</li>
</ul>
<p><strong>Decision</strong>:
Use MCP resources (and future explicit tools) without sandboxed execution. The
<code>run_script</code> tool is deprecated and removed from the backend.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li>(+) Simpler runtime and dependency footprint</li>
<li>(+) Clearer security posture without code execution</li>
<li>(-) Less flexibility until explicit MCP tools are added</li>
</ul>
<hr>
<h2>ADR-004: Local-First Storage</h2>
<p><strong>Status</strong>: Accepted</p>
<p><strong>Context</strong>: </p>
<ul>
<li>Users want control over their data</li>
<li>Cloud storage adds cost and complexity</li>
<li>Offline access is important for productivity</li>
</ul>
<p><strong>Decision</strong>: 
Use fsspec/OpenDAL for storage abstraction:</p>
<ul>
<li>Default: local filesystem</li>
<li>Optional: S3, GCS, Azure Blob</li>
<li>No required cloud services</li>
<li>Data format: JSON + Markdown (human-readable)</li>
</ul>
<p><strong>Consequences</strong>:</p>
<ul>
<li>(+) User owns their data completely</li>
<li>(+) Works offline</li>
<li>(+) Multiple storage backends supported</li>
<li>(-) No built-in sync (user must configure)</li>
<li>(-) No built-in backup (user responsibility)</li>
</ul>
<hr>
<h2>ADR-005: Optimistic Concurrency Control</h2>
<p><strong>Status</strong>: Accepted</p>
<p><strong>Context</strong>: </p>
<ul>
<li>Multiple clients may edit the same entry</li>
<li>Traditional locking is too restrictive</li>
<li>Users expect responsive UI</li>
</ul>
<p><strong>Decision</strong>: 
Use revision-based optimistic concurrency:</p>
<ul>
<li>Every entry has a <code>revision_id</code></li>
<li>Updates include <code>parent_revision_id</code></li>
<li>Server rejects if parent doesn&#39;t match current</li>
<li>Client handles 409 Conflict with merge UI</li>
</ul>
<p><strong>Consequences</strong>:</p>
<ul>
<li>(+) Responsive UI with optimistic updates</li>
<li>(+) No data loss (conflicts are surfaced)</li>
<li>(+) Simple implementation</li>
<li>(-) Users must resolve conflicts manually</li>
<li>(-) Last-write-wins would be simpler (but risky)</li>
</ul>
<hr>
<h2>ADR-006: Backend as Pure API Layer</h2>
<p><strong>Status</strong>: Accepted (Milestone 2)</p>
<p><strong>Context</strong>: </p>
<ul>
<li>Original backend contained business logic</li>
<li>Duplicated validation between backend and core logic</li>
<li>Hard to test backend in isolation</li>
</ul>
<p><strong>Decision</strong>: 
Backend should be a pure API layer:</p>
<ul>
<li>All business logic in <code>ugoite-core</code></li>
<li>Backend only routes requests and formats responses</li>
<li>No direct filesystem access in backend</li>
<li>Backend tests use memory filesystem via <code>ugoite-core</code></li>
</ul>
<p><strong>Consequences</strong>:</p>
<ul>
<li>(+) Single source of truth for business logic</li>
<li>(+) Easier to maintain and test</li>
<li>(+) Backend becomes simpler</li>
<li>(-) More abstraction layers</li>
<li>(-) Slightly more latency</li>
</ul>
<p><strong>Info</strong>: <code>ugoite-cli</code> is a separate tool for direct command-line interaction with <code>ugoite-core</code>.</p>
<hr>
<h2>ADR-007: YAML for Program-Readable Documentation</h2>
<p><strong>Status</strong>: Accepted (Milestone 2)</p>
<p><strong>Context</strong>: </p>
<ul>
<li>Markdown documentation is hard to parse programmatically</li>
<li>Need to verify documentation matches code</li>
<li>Requirements tracking is manual and error-prone</li>
</ul>
<p><strong>Decision</strong>: 
Use YAML for machine-readable specifications:</p>
<ul>
<li><code>features.yaml</code>: Feature paths across modules</li>
<li><code>requirements/*.yaml</code>: Requirements with test mapping</li>
<li><code>stories/*.yaml</code>: User stories with acceptance criteria</li>
<li>Automated tests verify consistency</li>
</ul>
<p><strong>Consequences</strong>:</p>
<ul>
<li>(+) Documentation is verifiable</li>
<li>(+) Requirements traceability is automated</li>
<li>(+) Easier to generate reports</li>
<li>(-) More structured format to maintain</li>
<li>(-) YAML can be verbose</li>
</ul>
 </article>  </main> </body></html>