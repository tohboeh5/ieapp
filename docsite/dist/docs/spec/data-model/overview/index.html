<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Docs: spec/data-model/overview.md</title><link rel="stylesheet" href="/_astro/_slug_.DCtb3bYL.css"></head> <body> <header class="mx-auto flex max-w-6xl flex-wrap items-center justify-between gap-3 px-4 py-4"> <a href="/" class="text-lg font-semibold">Ugoite Docsite</a> <nav class="flex items-center gap-4 text-sm"> <a href="/docs/guide/cli" class="underline-offset-2 hover:underline">CLI Guide</a> <a href="/docs/spec/api/rest" class="underline-offset-2 hover:underline">REST API</a> <a href="/docs/spec/api/mcp" class="underline-offset-2 hover:underline">MCP API</a> </nav> <div class="flex items-center gap-3"> <label for="theme" class="text-sm text-slate-600">Theme</label> <select id="theme" class="rounded-md border px-2 py-1 text-sm" data-theme-selector> <option value="materialize">Materialize</option><option value="classic">Classic</option><option value="pop">Pop</option> </select> <label for="mode" class="text-sm text-slate-600">Mode</label> <select id="mode" class="rounded-md border px-2 py-1 text-sm" data-mode-selector> <option value="light">Light</option> <option value="dark">Dark</option> </select> </div> <script type="module">const o="ugoite-ui-theme",l="ugoite-color-mode",m=document.documentElement,e=document.querySelector("[data-theme-selector]"),t=document.querySelector("[data-mode-selector]"),a=()=>{const c=e instanceof HTMLSelectElement?e.value:localStorage.getItem(o)||"materialize",n=t instanceof HTMLSelectElement?t.value:localStorage.getItem(l)||"light";m.dataset.uiTheme=c,m.dataset.colorMode=n,localStorage.setItem(o,c),localStorage.setItem(l,n)},i=localStorage.getItem(o)||"materialize",s=localStorage.getItem(l)||"light";e instanceof HTMLSelectElement&&(e.value=i,e.addEventListener("change",()=>{a()}));t instanceof HTMLSelectElement&&(t.value=s,t.addEventListener("change",()=>{a()}));a();</script> </header> <main class="mx-auto max-w-6xl px-4 pb-16">  <article class="prose max-w-none rounded-xl border p-6" style="background: var(--doc-card); border-color: var(--doc-border);"> <p class="mb-4 text-xs" style="color: var(--doc-muted);">Source: /docs/spec/data-model/overview.md</p> <h1>Data Model Overview</h1>
<p>This document describes the high-level data model of Ugoite, including its storage principles and directory structure.</p>
<h2>Terminology Distinction</h2>
<p>To ensure clarity, Ugoite distinguishes between the <strong>System Data Model</strong> and user-defined <strong>Forms</strong>:</p>
<ul>
<li><strong>System Data Model</strong>: The underlying architecture of how data is handled, stored, and retrieved (e.g., &quot;Filesystem = Database&quot;, directory structure, row-level integrity).</li>
<li><strong>Entry Forms</strong>: User-defined table schemas stored in Iceberg; templates are fixed globally. Formerly known as &quot;Schemas&quot;.</li>
</ul>
<h2>Principles</h2>
<p>Ugoite&#39;s data model is built on these principles:</p>
<table>
<thead>
<tr>
<th>Principle</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Filesystem = Database</strong></td>
<td>Spaces are directory trees; Iceberg tables are file-backed</td>
</tr>
<tr>
<td><strong>Form-on-Read</strong></td>
<td>Entries are reconstructed from Form-defined fields in Iceberg</td>
</tr>
<tr>
<td><strong>Append-Only Integrity</strong></td>
<td>Revisions are appended in Iceberg; history is immutable</td>
</tr>
<tr>
<td><strong>Table-Backed Storage</strong></td>
<td>Entries live in Apache Iceberg tables via OpenDAL</td>
</tr>
</tbody></table>
<h2>Directory Structure</h2>
<p>See <a href="directory-structure.md">directory-structure.md</a> for the full space layout.</p>
<pre><code>spaces/
  {space_id}/
    meta.json                  # Space metadata
    settings.json              # Space settings
    forms/                     # Iceberg-managed Form tables (layout not specified)
    assets/                    # Binary files
    materialized_views/        # SQL materialized view metadata (no rows)
    sql_sessions/              # SQL query sessions (metadata only)
</code></pre>
<h2>Key Concepts</h2>
<h3>Forms</h3>
<p>Forms define entry types with:</p>
<ul>
<li><strong>Template</strong>: Fixed global template <code># {form_name} + H2 columns</code></li>
<li><strong>Fields</strong>: Content columns derived from the Iceberg table schema</li>
<li><strong>Types</strong>: Iceberg column types mapped to entry fields</li>
<li><strong>Extra Attributes Policy</strong>: <code>allow_extra_attributes</code> controls non-registered H2 sections</li>
</ul>
<h3>Metadata vs Content Columns</h3>
<p>Ugoite separates columns into two ownership categories:</p>
<ul>
<li><strong>Metadata columns (system-owned)</strong>: Reserved fields created and managed by Ugoite.
Users <strong>cannot</strong> define Form fields with these names.</li>
<li><strong>Content columns (user-owned)</strong>: Form-defined fields stored in the Iceberg <code>fields</code> struct.</li>
</ul>
<p>Reserved metadata column names include (case-insensitive):</p>
<p><code>id</code>, <code>entry_id</code>, <code>title</code>, <code>form</code>, <code>tags</code>, <code>links</code>, <code>assets</code>,
<code>created_at</code>, <code>updated_at</code>, <code>revision_id</code>, <code>parent_revision_id</code>,
<code>deleted</code>, <code>deleted_at</code>, <code>author</code>, <code>integrity</code>,
<code>space_id</code>, <code>word_count</code>.</p>
<p>The metadata column list is treated as an internal system contract and may expand
over time; Form creation MUST reject any field name that conflicts with a
reserved metadata column name.</p>
<h3>Metadata Forms</h3>
<p>Ugoite also reserves <strong>metadata Form names</strong> for system-owned tables. Users cannot
create or update Forms with these names. The reserved metadata Form list is
case-insensitive and may expand over time.</p>
<p>Reserved metadata Form names include:</p>
<p><code>SQL</code></p>
<h3>SQL Materialized Views</h3>
<p>Saved SQL (created via <code>create_sql</code>) has a corresponding <strong>materialized view
metadata</strong> record under <code>spaces/{space_id}/materialized_views/</code>. The metadata is
created, updated, and deleted <strong>in lockstep</strong> with the SQL record. The metadata
record is the only persisted query artifact; SQL session results are not stored.</p>
<p>Materialized views are currently metadata-only placeholders. The on-disk layout
for future Iceberg-managed views beneath <code>materialized_views/</code> is intentionally
unspecified.</p>
<h3>SQL Sessions (Metadata Only)</h3>
<p>SQL sessions are short-lived (target: ~10 minutes) and store <strong>metadata only</strong>
under <code>spaces/{space_id}/sql_sessions/{session_id}/meta.json</code>. They do <strong>not</strong>
persist result rows. Session metadata includes a logical view snapshot ID and
paging strategy so that each request can re-run the SQL query quickly against
the current entries tables.</p>
<p>This keeps the system stateless beyond OpenDAL storage (no RDB, no external job
queue, no NFS), while still allowing multiple API servers to serve the same
session.</p>
<h3>Properties Extraction</h3>
<p>The write pipeline extracts properties from Markdown:</p>
<ol>
<li><strong>Frontmatter</strong>: YAML block at top of Markdown</li>
<li><strong>H2 Sections</strong>: <code>## Field Name</code> headers (must be Form-defined)</li>
<li><strong>Auto Properties</strong>: Computed values (word_count, etc.)</li>
</ol>
<p>Precedence: Section &gt; Frontmatter &gt; Auto default</p>
<p>Extra H2 sections are handled by the Form policy:</p>
<ul>
<li><code>deny</code>: reject entries with unknown H2 sections</li>
<li><code>allow_json</code>: store unknown sections in <code>extra_attributes</code></li>
<li><code>allow_columns</code>: accept unknown sections and store in <code>extra_attributes</code></li>
</ul>
<h3>Content Column Types &amp; Markdown Parsing</h3>
<p>Content column types map to Iceberg primitives and are parsed from Markdown
using Markdown-friendly rules:</p>
<ul>
<li><strong>string</strong>, <strong>markdown</strong> → stored as strings</li>
<li><strong>number</strong>, <strong>double</strong> → parsed as $f64$</li>
<li><strong>float</strong> → parsed as $f32$</li>
<li><strong>integer</strong> → parsed as $i32$</li>
<li><strong>long</strong> → parsed as $i64$</li>
<li><strong>boolean</strong> → parsed from <code>true/false</code>, <code>yes/no</code>, <code>on/off</code>, <code>1/0</code></li>
<li><strong>date</strong> → parsed as <code>YYYY-MM-DD</code></li>
<li><strong>time</strong> → parsed as <code>HH:MM:SS</code> or <code>HH:MM:SS.ssssss</code></li>
<li><strong>timestamp</strong> → parsed as RFC3339 (<code>2025-01-01T12:34:56Z</code>)</li>
<li><strong>timestamp_tz</strong> → parsed as RFC3339 and normalized to UTC</li>
<li><strong>timestamp_ns</strong> → parsed as RFC3339 with nanosecond precision</li>
<li><strong>timestamp_tz_ns</strong> → parsed as RFC3339 with nanosecond precision and normalized to UTC</li>
<li><strong>uuid</strong> → parsed as a canonical UUID string</li>
<li><strong>row_reference</strong> → stored as a string reference (e.g. entry ID or <code>ugoite://entry/{entry_id}</code>)
and MUST declare a <code>target_form</code> in the Form field definition. References resolve against
the target Form&#39;s <code>entry_id</code> metadata column.</li>
<li><strong>binary</strong> → parsed from <code>base64:</code> or <code>hex:</code> strings and stored as canonical <code>base64:</code></li>
<li><strong>list</strong> → parsed from Markdown bullet lists (e.g. <code>- item</code>)</li>
<li><strong>object_list</strong> → parsed from a JSON array of objects (each object must include
<code>type</code>, <code>name</code>, and <code>description</code> as strings)</li>
</ul>
<p>If a list is provided as plain lines, each non-empty line becomes an item.
Type casting errors are reported during validation.</p>
<h3>Link URIs</h3>
<p>Entries can contain Ugoite-internal links using the <code>ugoite://</code> scheme. The URI
kind determines the link target and is designed to be extensible:</p>
<ul>
<li><code>ugoite://entry/{entry_id}</code></li>
<li><code>ugoite://asset/{asset_id}</code></li>
</ul>
<p>Ugoite normalizes equivalent forms (e.g. <code>ugoite://entries/{id}</code>,
<code>ugoite://assets/{id}</code>, <code>ugoite://entry?id=...</code>) to canonical URIs on write.
This keeps Markdown stable while allowing new link kinds in future milestones.</p>
<h3>Versioning</h3>
<p>Every save creates a new revision row in the Iceberg <code>revisions</code> table:</p>
<ol>
<li>Client sends update with <code>parent_revision_id</code></li>
<li>Server validates parent matches current head</li>
<li>New revision row is appended via Iceberg</li>
<li><code>entries</code> table updated to new head</li>
</ol>
<p>Conflicts return HTTP 409 with current revision.</p>
<h2>Indices</h2>
<p>Materialized indexes (search, embeddings, stats) are derived from Iceberg tables
and can be regenerated. The Iceberg-managed layout is the only source of truth.</p>
<h2>Integrity</h2>
<p>All data is signed with HMAC:</p>
<ul>
<li>Root response-signing key stored in <code>hmac.json</code></li>
<li>Space integrity keys stored in each <code>spaces/{space_id}/meta.json</code></li>
<li>Signature stored alongside entry and revision rows</li>
<li>Checksum (SHA-256) for tamper detection</li>
</ul>
<h2>Extra Attributes Storage</h2>
<p>When allowed, unknown H2 sections are persisted in the <code>extra_attributes</code> column
as a deterministic JSON object. On read, <code>fields</code> and <code>extra_attributes</code> are
merged to reconstruct Markdown and properties.</p>
 </article>  </main> </body></html>