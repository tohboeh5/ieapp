<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Docs: spec/data-model/sql-sessions.md</title><link rel="stylesheet" href="/_astro/_slug_.DCtb3bYL.css"></head> <body> <header class="mx-auto flex max-w-6xl flex-wrap items-center justify-between gap-3 px-4 py-4"> <a href="/" class="text-lg font-semibold">Ugoite Docsite</a> <nav class="flex items-center gap-4 text-sm"> <a href="/docs/guide/cli" class="underline-offset-2 hover:underline">CLI Guide</a> <a href="/docs/spec/api/rest" class="underline-offset-2 hover:underline">REST API</a> <a href="/docs/spec/api/mcp" class="underline-offset-2 hover:underline">MCP API</a> </nav> <div class="flex items-center gap-3"> <label for="theme" class="text-sm text-slate-600">Theme</label> <select id="theme" class="rounded-md border px-2 py-1 text-sm" data-theme-selector> <option value="materialize">Materialize</option><option value="classic">Classic</option><option value="pop">Pop</option> </select> <label for="mode" class="text-sm text-slate-600">Mode</label> <select id="mode" class="rounded-md border px-2 py-1 text-sm" data-mode-selector> <option value="light">Light</option> <option value="dark">Dark</option> </select> </div> <script type="module">const o="ugoite-ui-theme",l="ugoite-color-mode",m=document.documentElement,e=document.querySelector("[data-theme-selector]"),t=document.querySelector("[data-mode-selector]"),a=()=>{const c=e instanceof HTMLSelectElement?e.value:localStorage.getItem(o)||"materialize",n=t instanceof HTMLSelectElement?t.value:localStorage.getItem(l)||"light";m.dataset.uiTheme=c,m.dataset.colorMode=n,localStorage.setItem(o,c),localStorage.setItem(l,n)},i=localStorage.getItem(o)||"materialize",s=localStorage.getItem(l)||"light";e instanceof HTMLSelectElement&&(e.value=i,e.addEventListener("change",()=>{a()}));t instanceof HTMLSelectElement&&(t.value=s,t.addEventListener("change",()=>{a()}));a();</script> </header> <main class="mx-auto max-w-6xl px-4 pb-16">  <article class="prose max-w-none rounded-xl border p-6" style="background: var(--doc-card); border-color: var(--doc-border);"> <p class="mb-4 text-xs" style="color: var(--doc-muted);">Source: /docs/spec/data-model/sql-sessions.md</p> <h1>SQL Sessions &amp; Materialized Views</h1>
<p><strong>Updated</strong>: 2026-02</p>
<p>This document defines how Ugoite manages SQL execution without persisting
large result sets. The design is <strong>stateless except for OpenDAL storage</strong> and
avoids RDBs, external job queues, or NFS-based shared disks.</p>
<h2>Constraints</h2>
<ul>
<li><strong>No RDB for session state</strong> (no PostgreSQL/MySQL/etc.).</li>
<li><strong>No external job queue</strong> (Celery/Redis/RabbitMQ, etc.).</li>
<li><strong>No NFS shared disk</strong>. OpenDAL storage is the only shared persistence.</li>
<li><strong>Short-lived sessions</strong> (target: ~10 minutes).</li>
<li><strong>Multiple API servers</strong> may serve the same session concurrently.</li>
</ul>
<h2>Materialized Views</h2>
<p>When a saved SQL is created (<code>create_sql</code>), a corresponding <strong>materialized view
metadata record</strong> MUST be created under:</p>
<pre><code>spaces/{space_id}/materialized_views/{sql_id}/
</code></pre>
<p>The materialized view lifecycle is <strong>synchronized</strong> with the SQL entry:</p>
<ul>
<li><strong>Create SQL</strong> → create materialized view metadata</li>
<li><strong>Update SQL</strong> → refresh/rebuild materialized view metadata</li>
<li><strong>Delete SQL</strong> → delete materialized view metadata</li>
</ul>
<p>Materialized views are currently <strong>metadata-only placeholders</strong>. The on-disk
layout of any future Iceberg-managed tables is owned by Iceberg and will be
specified when materialization is implemented.</p>
<h3>Materialized View Metadata (Optional)</h3>
<p>A lightweight metadata file may be stored at:</p>
<pre><code>spaces/{space_id}/materialized_views/{sql_id}/meta.json
</code></pre>
<p>Recommended fields:</p>
<pre><code class="language-json">{
  &quot;sql_id&quot;: &quot;sql-uuid&quot;,
  &quot;sql&quot;: &quot;SELECT * FROM Meeting&quot;,
  &quot;created_at&quot;: &quot;2026-02-10T12:00:00Z&quot;,
  &quot;updated_at&quot;: &quot;2026-02-10T12:05:00Z&quot;,
  &quot;snapshot_id&quot;: 42,
  &quot;schema_hash&quot;: &quot;sha256:...&quot;
}
</code></pre>
<h2>SQL Sessions (Metadata Only)</h2>
<p>SQL sessions store <strong>metadata only</strong> at:</p>
<pre><code>spaces/{space_id}/sql_sessions/{session_id}/meta.json
</code></pre>
<p>Sessions do <strong>not</strong> store result rows. Every query for rows/count re-runs the SQL
against the current entries tables; the <code>view.snapshot_id</code> field is a logical
marker reserved for future materialized view support.</p>
<h3>Session Metadata Schema (Recommended)</h3>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;session-uuid&quot;,
  &quot;space_id&quot;: &quot;space-uuid&quot;,
  &quot;sql_id&quot;: &quot;sql-uuid&quot;,
  &quot;sql&quot;: &quot;SELECT * FROM Meeting ORDER BY updated_at DESC LIMIT 50&quot;,
  &quot;status&quot;: &quot;ready&quot;,
  &quot;created_at&quot;: &quot;2026-02-10T12:00:00Z&quot;,
  &quot;expires_at&quot;: &quot;2026-02-10T12:10:00Z&quot;,
  &quot;error&quot;: null,
  &quot;view&quot;: {
    &quot;sql_id&quot;: &quot;sql-uuid&quot;,
    &quot;snapshot_id&quot;: 42,
    &quot;snapshot_at&quot;: &quot;2026-02-10T12:00:00Z&quot;,
    &quot;schema_version&quot;: 1
  },
  &quot;pagination&quot;: {
    &quot;strategy&quot;: &quot;offset&quot;,
    &quot;order_by&quot;: [&quot;updated_at&quot;, &quot;id&quot;],
    &quot;default_limit&quot;: 50,
    &quot;max_limit&quot;: 1000
  },
  &quot;count&quot;: {
    &quot;mode&quot;: &quot;on_demand&quot;,
    &quot;cached_at&quot;: null,
    &quot;value&quot;: null
  }
}
</code></pre>
<h3>Paging &amp; Count</h3>
<ul>
<li><strong>Rows</strong>: <code>offset</code>/<code>limit</code> is applied to the re-executed query against the
current entries tables.</li>
<li><strong>Count</strong>: computed on-demand with <code>SELECT COUNT(*)</code> against the same query.</li>
<li><strong>Fast paging</strong>: <code>order_by</code> in metadata MUST include a deterministic tie-breaker
(e.g., <code>id</code>) to avoid unstable pages.</li>
</ul>
<h3>Expiration &amp; Cleanup</h3>
<p>Sessions are short-lived. Implementations SHOULD delete expired session metadata
on a periodic sweep or when accessed after <code>expires_at</code>.</p>
<h2>Multi-Server Behavior</h2>
<p>Because the only persistence is OpenDAL storage, <strong>any API server</strong> can service
requests for the same session by reading <code>meta.json</code>, then re-running the SQL
query against the current entries tables.</p>
 </article>  </main> </body></html>