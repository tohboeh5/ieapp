<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Docs: spec/features/sql.md</title><link rel="stylesheet" href="/_astro/_slug_.DCtb3bYL.css"></head> <body> <header class="mx-auto flex max-w-6xl flex-wrap items-center justify-between gap-3 px-4 py-4"> <a href="/" class="text-lg font-semibold">Ugoite Docsite</a> <nav class="flex items-center gap-4 text-sm"> <a href="/docs/guide/cli" class="underline-offset-2 hover:underline">CLI Guide</a> <a href="/docs/spec/api/rest" class="underline-offset-2 hover:underline">REST API</a> <a href="/docs/spec/api/mcp" class="underline-offset-2 hover:underline">MCP API</a> </nav> <div class="flex items-center gap-3"> <label for="theme" class="text-sm text-slate-600">Theme</label> <select id="theme" class="rounded-md border px-2 py-1 text-sm" data-theme-selector> <option value="materialize">Materialize</option><option value="classic">Classic</option><option value="pop">Pop</option> </select> <label for="mode" class="text-sm text-slate-600">Mode</label> <select id="mode" class="rounded-md border px-2 py-1 text-sm" data-mode-selector> <option value="light">Light</option> <option value="dark">Dark</option> </select> </div> <script type="module">const o="ugoite-ui-theme",l="ugoite-color-mode",m=document.documentElement,e=document.querySelector("[data-theme-selector]"),t=document.querySelector("[data-mode-selector]"),a=()=>{const c=e instanceof HTMLSelectElement?e.value:localStorage.getItem(o)||"materialize",n=t instanceof HTMLSelectElement?t.value:localStorage.getItem(l)||"light";m.dataset.uiTheme=c,m.dataset.colorMode=n,localStorage.setItem(o,c),localStorage.setItem(l,n)},i=localStorage.getItem(o)||"materialize",s=localStorage.getItem(l)||"light";e instanceof HTMLSelectElement&&(e.value=i,e.addEventListener("change",()=>{a()}));t instanceof HTMLSelectElement&&(t.value=s,t.addEventListener("change",()=>{a()}));a();</script> </header> <main class="mx-auto max-w-6xl px-4 pb-16">  <article class="prose max-w-none rounded-xl border p-6" style="background: var(--doc-card); border-color: var(--doc-border);"> <p class="mb-4 text-xs" style="color: var(--doc-muted);">Source: /docs/spec/features/sql.md</p> <h1>Ugoite SQL (Domain-Specific SQL)</h1>
<p><strong>Version</strong>: 0.1
<strong>Updated</strong>: 2026-01</p>
<p>Ugoite SQL provides a lightweight SQL dialect for querying Iceberg-backed entries.
It is designed for filtering and sorting entry records without changing API paths.</p>
<h2>Scope</h2>
<ul>
<li><strong>Supported</strong>: <code>SELECT *</code> with <code>FROM</code>, <code>WHERE</code>, <code>ORDER BY</code>, <code>LIMIT</code>, and <code>JOIN</code>.</li>
<li><strong>Join support</strong>: <code>INNER</code>, <code>LEFT</code>, <code>RIGHT</code>, <code>FULL</code>, and <code>CROSS</code> joins with
<code>ON</code>, <code>USING</code>, and <code>NATURAL</code> constraints.</li>
<li><strong>Not supported</strong>: <code>GROUP BY</code>, <code>SELECT field projection</code>, subqueries,
correlated subqueries.</li>
<li><strong>Execution</strong>: In-memory evaluation over records derived from Iceberg tables.</li>
<li><strong>Safety limits</strong>: Implementations MUST cap results to a server-side maximum
(default 1000 rows) even when <code>LIMIT</code> is omitted.</li>
</ul>
<h2>Materialized Views &amp; Sessions</h2>
<ul>
<li>Saved SQL (<code>create_sql</code>) <strong>creates materialized view metadata</strong> under
<code>spaces/{space_id}/materialized_views/{sql_id}/</code>.</li>
<li>Updates/deletes of saved SQL <strong>refresh/remove</strong> the corresponding metadata.</li>
<li>SQL sessions store <strong>metadata only</strong> (no result rows); <code>view.snapshot_id</code> is a
logical marker reserved for future materialized view support.</li>
<li>Session metadata is stored under
<code>spaces/{space_id}/sql_sessions/{session_id}/meta.json</code> and is short-lived
(target: ~10 minutes).</li>
<li>The design is <strong>stateless beyond OpenDAL storage</strong> (no RDB, no external
job queue, no NFS shared disks).</li>
</ul>
<h2>Tables</h2>
<ul>
<li><code>entries</code> — All entries across forms.</li>
<li><code>&lt;FormName&gt;</code> — Entries scoped to a specific form.</li>
<li><code>links</code> — Link rows (id, source, target, kind, source_form, target_form).</li>
<li><code>assets</code> — Asset rows (id, entry_id, name, path).</li>
</ul>
<h2>Columns</h2>
<ul>
<li>Standard columns: <code>id</code>, <code>title</code>, <code>form</code>, <code>updated_at</code>, <code>space_id</code>, <code>word_count</code>, <code>tags</code>.</li>
<li>Form fields: Use field names directly (e.g., <code>Date</code>, <code>Owner</code>) or <code>properties.&lt;field&gt;</code>.</li>
<li>Join columns: Use table-qualified names when joining (e.g., <code>n.id</code>, <code>l.target</code>).</li>
<li>Complex join predicates (AND/OR, nested conditions) are supported.</li>
</ul>
<h2>Saved SQL Form</h2>
<p>Ugoite defines a system-owned <strong>SQL</strong> Form for persisting saved queries.
The SQL Form is a <strong>metadata Form</strong>; users cannot create Forms with the
reserved name <code>SQL</code>.</p>
<p>SQL Form fields:</p>
<ul>
<li><code>sql</code> (markdown/string): SQL query text</li>
<li><code>variables</code> (object_list): JSON array of objects with <code>type</code>, <code>name</code>, and
<code>description</code></li>
</ul>
<p>Saved SQL entries MUST embed every variable in the <code>sql</code> text using
<code>{{variable_name}}</code> placeholders. Placeholders MUST correspond to entries in
<code>variables</code>, and the SQL must be valid Ugoite SQL after substituting placeholders
with literal values.</p>
<h2>Examples</h2>
<pre><code class="language-sql">SELECT *
FROM entries
WHERE form = &#39;Meeting&#39; AND updated_at &gt;= {{since}}
ORDER BY updated_at DESC
LIMIT 50
</code></pre>
<pre><code class="language-sql">SELECT * FROM Meeting WHERE Date &gt;= &#39;2025-01-01&#39; AND tags = &#39;project&#39;
</code></pre>
<pre><code class="language-sql">SELECT * FROM entries WHERE properties.Owner = &#39;alice&#39;
</code></pre>
<pre><code class="language-sql">SELECT *
FROM entries n
JOIN links l ON n.id = l.source
WHERE l.kind = &#39;reference&#39;
ORDER BY n.updated_at DESC
LIMIT 100
</code></pre>
<pre><code class="language-sql">SELECT *
FROM entries n
RIGHT JOIN links l ON n.id = l.source
WHERE l.target = &#39;entry-2&#39;
</code></pre>
<pre><code class="language-sql">SELECT *
FROM entries n
FULL JOIN entries m USING (id)
WHERE n.id IS NOT NULL
</code></pre>
<h2>Errors</h2>
<p>Invalid syntax or unsupported clauses must return an error from <code>ugoite-core</code> and
surface as a <code>400</code> or <code>500</code> response depending on the caller context.
Limits that exceed the server-side maximum must return a validation error.</p>
<h2>Lint &amp; Completion Rules</h2>
<p>Linting and completion rules are defined in the shared configuration file:</p>
<ul>
<li><code>shared/sql/ugoite-sql-rules.json</code></li>
</ul>
<p><code>ugoite-core</code> reads this file to provide CLI linting/completion behavior, while
the frontend uses the same file for editor hints without requiring runtime API
calls.</p>
<h2>Integration</h2>
<p>Clients send SQL via the existing structured query payload:</p>
<pre><code class="language-json">{
  &quot;filter&quot;: {
    &quot;$sql&quot;: &quot;SELECT * FROM entries WHERE form = &#39;Meeting&#39;&quot;
  }
}
</code></pre>
 </article>  </main> </body></html>