---
import { promises as fs } from "node:fs";
import path from "node:path";
import { Marked } from "marked";
import BaseLayout from "../../layouts/BaseLayout.astro";

function escapeHtml(raw: string): string {
  return raw
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function escapeAttribute(raw: string): string {
  return escapeHtml(raw).replaceAll("`", "&#96;");
}

function sanitizeUrl(raw: string | null | undefined): string | null {
  if (!raw) return null;
  const trimmed = raw.trim();
  if (trimmed.length === 0) return null;

  if (
    trimmed.startsWith("/") ||
    trimmed.startsWith("./") ||
    trimmed.startsWith("../") ||
    trimmed.startsWith("#")
  ) {
    return trimmed;
  }

  try {
    const parsed = new URL(trimmed, "https://example.local");
    if (parsed.protocol === "http:" || parsed.protocol === "https:") {
      return trimmed;
    }
  } catch {
    return null;
  }

  return null;
}

const safeMarked = new Marked({
  gfm: true,
});

safeMarked.use({
  renderer: {
    html(token) {
      return escapeHtml(token.text);
    },
    link({ href, title, text }) {
      const safeHref = sanitizeUrl(href);
      const safeText = escapeHtml(text ?? href ?? "link");
      if (!safeHref) {
        return safeText;
      }

      const titleAttr = title ? ` title="${escapeAttribute(title)}"` : "";
      return `<a href="${escapeAttribute(safeHref)}"${titleAttr} rel="noopener noreferrer">${safeText}</a>`;
    },
    image({ href, title, text }) {
      const safeSrc = sanitizeUrl(href);
      if (!safeSrc) {
        return "";
      }

      const safeAlt = escapeAttribute(text ?? "");
      const titleAttr = title ? ` title="${escapeAttribute(title)}"` : "";
      return `<img src="${escapeAttribute(safeSrc)}" alt="${safeAlt}"${titleAttr} loading="lazy" decoding="async" />`;
    },
  },
});

export async function getStaticPaths() {
  const docsRoot = path.resolve(process.cwd(), "../docs");
  const walkMarkdownFiles = async (dir: string): Promise<string[]> => {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) return await walkMarkdownFiles(fullPath);
        if (entry.isFile() && entry.name.endsWith(".md")) return [fullPath];
        return [];
      })
    );
    return files.flat();
  };

  const markdownFiles = await walkMarkdownFiles(docsRoot);
  return markdownFiles.map((file) => {
    const relative = path.relative(docsRoot, file).replace(/\\/g, "/");
    const slug = relative.replace(/\.md$/, "");
    return { params: { slug } };
  });
}

const docsRoot = path.resolve(process.cwd(), "../docs");
const slugPath = String(Astro.params.slug || "").replace(/^\/+/, "");
const relativePath = `${slugPath}.md`;
const fullPath = path.join(docsRoot, relativePath);
const markdown = await fs.readFile(fullPath, "utf-8");
const html = safeMarked.parse(markdown);
const parts = slugPath.split("/").filter(Boolean);
const breadcrumbs = parts.map((part, index) => ({
  label: part,
  href: `/docs/${parts.slice(0, index + 1).join("/")}`,
}));
---

<BaseLayout title={`Docs: ${relativePath}`} description={`Repository source: /docs/${relativePath}`}>
  <section class="doc-card mb-4">
    <nav class="text-xs" style="color: var(--doc-muted);">
      <a href="/">home</a>
      <span> / </span>
      <a href="/docs/spec/index">docs</a>
      {breadcrumbs.map((crumb) => (
        <>
          <span> / </span>
          <a href={crumb.href}>{crumb.label}</a>
        </>
      ))}
    </nav>
    <p class="mt-2 text-xs" style="color: var(--doc-muted);">Source: /docs/{relativePath}</p>
  </section>
  <article class="prose doc-prose max-w-none">
    <Fragment set:html={html} />
  </article>
</BaseLayout>
